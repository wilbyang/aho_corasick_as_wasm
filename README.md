<div align="center">
  <h1><code>aho_corasick_as_wasm</code></h1>
  <strong>High-performance multi-pattern string searching (Aho–Corasick) compiled to WebAssembly.</strong>
  <p>Rust implementation exposed to JavaScript via <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>.</p>
  <p>
    <a href="https://crates.io/crates/aho-corasick">Rust crate</a> •
    <a href="#quick-start">Quick Start</a> •
    <a href="#api">API</a>
  </p>
</div>

## Why

If you need to search for many patterns efficiently (e.g. keyword filtering, highlighting, token detection) the Aho–Corasick algorithm builds a finite automaton that scans the text in a single pass. By compiling it to WebAssembly you get near-native performance in browsers and Node.js with predictable results and a tiny surface area.

## Features

* Multiple pattern matching in linear time over the input text.
* Returns precise match spans `{ pattern_index, start, end }` (indexes are byte offsets; patterns use original array order).
* Deterministic Standard (non-overlapping) match semantics.
* Automatic panic hook (better error messages) – initialized at module start.
* Typed output via `*.d.ts` definitions generated by `wasm-pack`.
* Zero unsafe JS glue: all communication through `wasm-bindgen` + `serde_wasm_bindgen`.

## Build

```bash
# Release build (recommended for production)
wasm-pack build --release

# Debug build (faster iteration)
wasm-pack build
```

The output will be in `pkg/`. You can publish that as an npm package or consume it directly with a bundler.

## Installation

Until published to npm, use a local path:

```bash
# Inside a JS/TS project
npm install --save ./path/to/aho_corasick_as_wasm/pkg
```

Or with pnpm:

```bash
pnpm add ./path/to/aho_corasick_as_wasm/pkg
```

After publishing, you'll just:

```bash
npm install aho_corasick_as_wasm
```

## Quick Start

```ts
import init, { AhoSearcher } from 'aho_corasick_as_wasm';

// Some bundlers auto-initialize; to be safe:
await init();

const searcher = new AhoSearcher(["he", "she", "hers", "his"]);
const haystack = "ushers";
const matches = searcher.search(haystack);

// Example matches (Standard, non-overlapping):
// [ { pattern_index: 1, start: 1, end: 4 }, ... ]
console.log(matches);
```

### In the Browser (no bundler)

```html
<script type="module">
  import init, { AhoSearcher } from './pkg/my_wasm_project.js';
  await init();
  const s = new AhoSearcher(["abc", "bcd"]);
  console.log(s.search("xxabcdxx"));
</script>
```

## API

### Class: `AhoSearcher`

| Member | Signature | Description |
|--------|-----------|-------------|
| constructor | `new AhoSearcher(patterns: string[])` | Builds an automaton for all given patterns. Throws `JsValue` with an error message (may contain Chinese text) if initialization fails. |
| `search` | `search(haystack: string): MatchResult[]` | Scans `haystack` and returns an array of matches. |

### Type: `MatchResult`

```ts
interface MatchResult {
  pattern_index: number; // index of the matched pattern in the original array
  start: number;         // byte offset start
  end: number;           // byte offset end (exclusive)
}
```

Notes:
* Currently uses `MatchKind::Standard`; overlapped matches are not exposed yet.
* Byte offsets align with JS string UTF-16 code unit boundaries for ASCII; if using non-ASCII you may need to map to code points.

## Error Handling

Errors are returned as `JsValue` (exception thrown in JS) with descriptive text. Example causes:
* Invalid pattern list (not an array of strings).
* Internal build failure constructing the automaton.

## Testing

You can add/extend Rust tests or run browser tests:

```bash
wasm-pack test --headless --firefox
```

(Add Chrome with `--chrome` if installed.)

## Performance Tips

* Use `--release` for real benchmarks.
* Reuse a single `AhoSearcher` instance—construction is the expensive part.
* Group related patterns to minimize unnecessary automaton size.
* Consider exposing additional builder options (e.g. `ascii_case_insensitive`) in future if needed.

## Roadmap

* Optional overlapped match mode.
* Case-insensitive and Unicode mode exposure.
* Streaming/chunked input processing.
* Benchmarks vs pure JS implementations.

## Contributing

PRs welcome. Please open an issue describing any new API surface before implementation so we can keep the footprint minimal.

## License

Licensed under either of:

* Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
* MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.

Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work shall be dual licensed as above, without additional terms.

## Acknowledgements

Powered by the excellent Rust [`aho-corasick`](https://crates.io/crates/aho-corasick) crate and the Rust ↔︎ WebAssembly ecosystem.
